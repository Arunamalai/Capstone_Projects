#Project Title:AgriData Explorer: Understanding Indian agriculture with EDA
import pandas as pd
data=pd.read_csv("C:/Users/Arunamalai/Downloads/ICRISAT-District Level Data - ICRISAT-District Level Data.csv")
data
data.info()
data.isnull().sum()
data.describe()
data[data<0]=0
print(data)
data.loc[:, data.select_dtypes(include=['number']).columns] = data.select_dtypes(include=['number']).applymap(lambda x: 0 if x < 0 else x)
print(data)
contains_hyphen = data.applymap(lambda x: '-' in str(x))

print("Does the DataFrame contain the hyphen (-)?")
print(contains_hyphen)
a=data.groupby('State Name')
print(a.ngroups)
print(a.size())
a=data.groupby('State Name').agg({'RICE YIELD (Kg per ha)':'mean'})
a.apply(display)
a=data.groupby(['State Name','Dist Name']).agg({'RICE YIELD (Kg per ha)':['mean','count']})
display(a)
a=data[data['RICE AREA (1000 ha)']>1000]
display(a)
data['Dist Code']=data['Dist Code'].astype('string')
data['State Code']=data['State Code'].astype('string')
data['Dist Code'].str.upper()
print(data)
data.columns = data.columns.str.upper()
data['State Name'].unique()
print(data['COTTON AREA (1000 HA)'].max())
print(data['COTTON AREA (1000 HA)'].min())
data = data.applymap(lambda x: x.rstrip() if isinstance(x, str) else x)#Removing trailing space in string columns for full dataframe
print(data)
data[data.duplicated()]
%pip install seaborn

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame with columns 'year' and 'rice_production'
sns.boxplot(data=data, x='YEAR', y='RICE PRODUCTION (1000 TONS)')

# Add titles and labels
plt.title('Distribution of Rice Production by Year')
plt.xlabel('YEAR')
plt.ylabel('RICE PRODUCTION (1000 TONS)')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

import seaborn as sns
import matplotlib.pyplot as plt

# Assuming 'df' is your DataFrame with columns 'year' and 'rice_production'
sns.boxplot(data=data, x='YEAR', y='RICE PRODUCTION (1000 TONS)')

# Add titles and labels
plt.title('Distribution of Rice Production by Year')
plt.xlabel('YEAR')
plt.ylabel('RICE PRODUCTION (1000 TONS)')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

sns.violinplot(data=past_20_year_data, x='YEAR', y='RICE PRODUCTION (1000 TONS)')
plt.title('Distribution of Rice Production for the Past 20 Years')
plt.xlabel('Year')
plt.ylabel('Rice Production')
plt.xticks(rotation=45)  # Rotate x-axis labels for better readability
plt.show()

a=data.groupby('YEAR')
print(a.ngroups)
print(a.size())
%pip install scipy

import scipy.stats as stats

# Assuming 'df' is your DataFrame with columns 'rice_production' and 'rice_area'

# Calculate the Pearson correlation between 'rice_production' and 'rice_area'
correlation, _ = stats.pearsonr(data['RICE PRODUCTION (1000 TONS)'], data['RICE AREA (1000 HA)'])

# Print the correlation, rounded to 4 decimal places
print(round(correlation, 2))#output nearly 1. so there is positive correlation between rice_production' and 'rice_area

import scipy.stats as stats

# Assuming 'df' is your DataFrame with columns 'rice_production' and 'rice_area'

# Calculate the Pearson correlation between 'rice_production' and 'rice_area'
correlation, _ = stats.pearsonr(data['WHEAT AREA (1000 HA)'], data['POTATOES AREA (1000 HA)'])

# Print the correlation, rounded to 4 decimal places
print(round(correlation, 2))#(nearly 0 there is no correlation)

import seaborn as sns
import matplotlib.pyplot as plt
numeric_data = data.select_dtypes(include=[float, int])  # Select only numeric columns

# Now calculate the correlation matrix

correlation_matrix = numeric_data.corr()

plt.figure(figsize=(50, 50)) # Adjust figure size as needed
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Correlation Matrix Heatmap')
plt.show()

%pip install statsmodels

from statsmodels.stats.weightstats import ztest as ztest
import scipy.stats as stats

data1=data['RICE PRODUCTION (1000 TONS)']
data2=data['RICE AREA (1000 HA)']

print(ztest(data1,data2,value=0))
print(stats.ttest_ind(a=data1, b=data2, equal_var=True))

from statsmodels.stats.weightstats import ztest as ztest
import scipy.stats as stats

data1=data['RICE PRODUCTION (1000 TONS)']
data2=data['WHEAT PRODUCTION (1000 TONS)']

print(ztest(data1,data2,value=0))
print(stats.ttest_ind(a=data1, b=data2, equal_var=True))

import scipy.stats as stats

# Assuming 'data' is your DataFrame with columns 'STATE NAME' and 'RICE PRODUCTION (1000 TONS)'

# Perform one-way ANOVA to check if rice production differs across states
f_stat, p_value = stats.f_oneway(
    *(data[data['STATE NAME'] == state]['RICE PRODUCTION (1000 TONS)'] for state in data['STATE NAME'].unique())
)

# Print the F-statistic and p-value
print(f"F-statistic: {f_stat}, p-value: {p_value}")# opt:there are dependent(there is a connection bt STATE NAME' and 'RICE PRODUCTION)


data1 = data.iloc[:,[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19]] 
data1

data2 = data.iloc[:,[0,1,2,3,4,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37]] 
data2
data3=data.iloc[:,[0,1,2,3,4,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58]]
data3

data4=data.iloc[:,[0,1,2,3,4,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79]]
data4

%pip install mysql-connector-python

import mysql.connector

connection = mysql.connector.connect(
  host = "gateway01.ap-southeast-1.prod.aws.tidbcloud.com",
  port = 4000,
  user = "3sqybL7f77eBaEc.root",
  password = "1ZeuUOPIkdgfGfnY",
  database = "Capstone"
)
mycursor=connection.cursor()

mycursor.execute("""
CREATE TABLE data1 (
    `DIST CODE` VARCHAR(255),
    `YEAR` INT(4),
    `STATE CODE` VARCHAR(255),
    `STATE NAME` VARCHAR(255),
    `DIST NAME` VARCHAR(255),
    `RICE AREA (1000 HA)` FLOAT,
    `RICE PRODUCTION (1000 TONS)` FLOAT,
    `RICE YIELD (KG PER HA)` FLOAT,
    `WHEAT AREA (1000 HA)` FLOAT,
    `WHEAT PRODUCTION (1000 TONS)` FLOAT,
    `WHEAT YIELD (KG PER HA)` FLOAT,
    `KHARIF SORGHUM AREA (1000 HA)` FLOAT,
    `KHARIF SORGHUM PRODUCTION (1000 TONS)` FLOAT,
    `KHARIF SORGHUM YIELD (KG PER HA)` FLOAT,
    `RABI SORGHUM AREA (1000 HA)` FLOAT,
    `RABI SORGHUM PRODUCTION (1000 TONS)` FLOAT,
    `RABI SORGHUM YIELD (KG PER HA)` FLOAT,
    `SORGHUM AREA (1000 HA)` FLOAT,
    `SORGHUM PRODUCTION (1000 TONS)` FLOAT,
    `SORGHUM YIELD (KG PER HA)` FLOAT
)
""")

import pandas as pd
import mysql.connector

def insert_dataframe_into_sql(df, connection, table_name):
    """
    Inserts a Pandas DataFrame into an SQL table.

    Args:
        df: The Pandas DataFrame to insert.
        connection: An active MySQLdb connection object.
        table_name: The name of the table to insert into.
    """
    mycursor = connection.cursor()

    # Efficiently insert data in chunks
    chunk_size = 1000  # Adjust chunk size based on your database and network
    for i in range(0, len(df), chunk_size):
        chunk = df[i:i + chunk_size]
        values = []
        for index, row in chunk.iterrows():
            # Replace NaN with None for SQL compatibility
            row = row.where(pd.notna(row), None)  
            values.append(tuple(row))

        # Escape column names with backticks to handle special characters like spaces and parentheses
        columns = ', '.join([f"`{col}`" for col in df.columns])  # Add backticks around column names

        # Create placeholders for the SQL query
        placeholders = ', '.join(['%s'] * len(df.columns))
        
        sql = f"INSERT INTO `{table_name}` ({columns}) VALUES ({placeholders})"

        try:
            # Insert the values in bulk
            mycursor.executemany(sql, values)
            connection.commit()  # Commit after each chunk for better performance and resilience
        except mysql.connector.Error as err:
            print(f"Error inserting chunk: {err}")
            connection.rollback()  # Rollback the transaction if an error occurs

    mycursor.close()

# Example of how to use the function
# Assuming you already have a connection object and your DataFrame `data1`
# Insert the DataFrame into the 'data1' table

insert_dataframe_into_sql(data1, connection, 'data1')

# Close the connection after the insert
connection.close()

mycursor.execute("""CREATE TABLE data2 (
    `DIST CODE` VARCHAR(255),
    `YEAR` INT(4),
    `STATE CODE` VARCHAR(255),
    `STATE NAME` VARCHAR(255),
    `DIST NAME` VARCHAR(255),
    `PEARL MILLET AREA (1000 HA)` FLOAT,
    `PEARL MILLET PRODUCTION (1000 TONS)` FLOAT,
    `PEARL MILLET YIELD (KG PER HA)` FLOAT,
    `MAIZE AREA (1000 HA)` FLOAT,
    `MAIZE PRODUCTION (1000 TONS)` FLOAT,
    `MAIZE YIELD (KG PER HA)` FLOAT,
    `FINGER MILLET AREA (1000 HA)` FLOAT,
    `FINGER MILLET PRODUCTION (1000 TONS)` FLOAT,
    `FINGER MILLET YIELD (KG PER HA)` FLOAT,
    `BARLEY AREA (1000 HA)` FLOAT,
    `BARLEY PRODUCTION (1000 TONS)` FLOAT,
    `BARLEY YIELD (KG PER HA)` FLOAT,
    `CHICKPEA AREA (1000 HA)` FLOAT,
    `CHICKPEA PRODUCTION (1000 TONS)` FLOAT,
    `CHICKPEA YIELD (KG PER HA)` FLOAT,
    `PIGEONPEA AREA (1000 HA)` FLOAT,
    `PIGEONPEA PRODUCTION (1000 TONS)` FLOAT,
    `PIGEONPEA YIELD (KG PER HA)` FLOAT)"""
)

